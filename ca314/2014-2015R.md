Paper link: https://drive.google.com/file/d/0B4T0-Ia20_9ZandhclcyY0pPUlU/view

####Question 1
(a)
The Liskov Substitution Principle (LSP) states that subclasses should be able to substitute for their base classes.
Explain how this principle may be expressed in terms of two rules that, in part, involve class invariant(s) and operation pre- and post-conditions.

######Answer:
This can be expressed easily in two rules:
1. Invariants (ie conditions that must remain true) of the supertype must be preserved in a subtype.
2. Pre- and post-conditions have specific rules of their own regarding the strength/power within subtypes:
  - Pre-conditions cannot be strengthened within a subtype.
  - Post-conditions cannot be weakened within a subtype.

(b)
Consider the Java code specified in the Appendix to this paper.
Explain why this code violates the LSP. Also explain how this code may cause a divide by zero to occur.

######Answer:
AutomaticSpeedController inherits adjustSpeed() from SpeedController but overwrites it with "do nothing". This makes the method specific to AutomaticSpeedController, meaning it can no longer be used in the smae way for SpeedController, violating the LSP.

This code can cause a divide by zero as in SpeedController speed is set to 0 within the class. This is then used in timeToGo() through getSpeed() and results in the devide by zero.

(c)
What code changes would need to be made in order to conform to the LSP?

######Answer:

####Question 2
(a)
Explain the main syntactical elements of the following class diagram.

######Answer:

(b)
Depict and describe, usign a non-trivial example diagram, the main features of UML sequence diagrams including highlighting when an object is computing, depiction of time constraints, return of values, creation and deletion of objects, representation of conditional behaviour and of iteration, and modelling of several threads of control.

######Answer:


####Question 3
(a)
Explain, using an exmaple, the main elements of protocol state machiens. Explain also the differences between ordinary (behavioural) state machines and protocol state machines.


(b)
It is almost always a good principle to incorporate flexibility in a software design in order to accommodate future changes in requirements. Give brief examples (with appropriate UML diagrams) to uillustrate designing for
  - adding more of the same kind of functionality
  - adding different functionality

(c)
One way 
